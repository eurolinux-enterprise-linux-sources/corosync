From 6fae42ba72006941c1fde99616ea30f4f10ebb38 Mon Sep 17 00:00:00 2001
From: Jan Friesse <jfriesse@redhat.com>
Date: Thu, 8 Nov 2012 13:15:12 +0100
Subject: [PATCH] Fix problem with sync operations under very rare circumstances

This patch creates a special message queue for synchronization messages.
This prevents a situation in which messages are queued in the
new_message_queue but have not yet been originated from corrupting the
synchronization process.

Signed-off-by: Steven Dake <sdake@redhat.com>
Reviewed-by: Jan Friesse <jfriesse@redhat.com>
Reviewed-by: Fabio M. Di Nitto <fdinitto@redhat.com>
(backport from needle)
---
 exec/main.c                      |    4 +++
 exec/totemmrp.c                  |    5 +++
 exec/totemmrp.h                  |    2 +
 exec/totempg.c                   |    5 +++
 exec/totemsrp.c                  |   53 +++++++++++++++++++++++++++++++++++---
 exec/totemsrp.h                  |    3 ++
 include/corosync/totem/totempg.h |    2 +
 7 files changed, 70 insertions(+), 4 deletions(-)

diff --git a/exec/main.c b/exec/main.c
index b6eff64..1d581ff 100644
--- a/exec/main.c
+++ b/exec/main.c
@@ -273,6 +273,10 @@ static void corosync_sync_completed (void)
 	log_printf (LOGSYS_LEVEL_NOTICE,
 		"Completed service synchronization, ready to provide service.\n");
 	sync_in_process = 0;
+	/*
+	 * Inform totem to start using new message queue again
+	 */
+	totempg_trans_ack();
 }
 
 static int corosync_sync_callbacks_retrieve (int sync_id,
diff --git a/exec/totemmrp.c b/exec/totemmrp.c
index 75ddf98..56fb9b0 100644
--- a/exec/totemmrp.c
+++ b/exec/totemmrp.c
@@ -267,3 +267,8 @@ int totemmrp_member_remove (
 
 	return (res);
 }
+
+void totemmrp_trans_ack (void)
+{
+	totemsrp_trans_ack (totemsrp_context);
+}
diff --git a/exec/totemmrp.h b/exec/totemmrp.h
index d351072..d477648 100644
--- a/exec/totemmrp.h
+++ b/exec/totemmrp.h
@@ -124,4 +124,6 @@ extern int totemmrp_member_remove (
 	const struct totem_ip_address *member,
 	int ring_no);
 
+void totemmrp_trans_ack (void);
+
 #endif /* TOTEMMRP_H_DEFINED */
diff --git a/exec/totempg.c b/exec/totempg.c
index 0ec542c..7c58e38 100644
--- a/exec/totempg.c
+++ b/exec/totempg.c
@@ -1410,3 +1410,8 @@ extern int totempg_member_add (
 extern int totempg_member_remove (
 	const struct totem_ip_address *member,
 	int ring_no);
+
+void totempg_trans_ack (void)
+{
+	totemmrp_trans_ack ();
+}
diff --git a/exec/totemsrp.c b/exec/totemsrp.c
index 92f3c06..9a1bb85 100644
--- a/exec/totemsrp.c
+++ b/exec/totemsrp.c
@@ -368,6 +368,8 @@ struct totemsrp_instance {
 	 */
 	struct cs_queue new_message_queue;
 
+	struct cs_queue new_message_queue_trans;
+
 	struct cs_queue retrans_message_queue;
 
 	struct sq regular_sort_queue;
@@ -497,6 +499,8 @@ struct totemsrp_instance {
 
 	uint32_t orf_token_discard;
 	
+	uint32_t waiting_trans_ack;
+
 	void * token_recv_event_handle;
 	void * token_sent_event_handle;
 	char commit_token_storage[40000];
@@ -675,6 +679,8 @@ static void totemsrp_instance_initialize (struct totemsrp_instance *instance)
 	instance->orf_token_discard = 0;
 
 	instance->commit_token = (struct memb_commit_token *)instance->commit_token_storage;
+
+	instance->waiting_trans_ack = 1;
 }
 
 static void main_token_seqid_get (
@@ -945,6 +951,10 @@ int totemsrp_initialize (
 		MESSAGE_QUEUE_MAX,
 		sizeof (struct message_item));
 
+	cs_queue_init (&instance->new_message_queue_trans,
+		MESSAGE_QUEUE_MAX,
+		sizeof (struct message_item));
+
 	totemsrp_callback_token_create (instance,
 		&instance->token_recv_event_handle,
 		TOTEM_CALLBACK_TOKEN_RECEIVED,
@@ -1771,6 +1781,7 @@ static void memb_state_operational_enter (struct totemsrp_instance *instance)
 		trans_memb_list_totemip, instance->my_trans_memb_entries,
 		left_list, instance->my_left_memb_entries,
 		0, 0, &instance->my_ring_id);
+	instance->waiting_trans_ack = 1;
 
 // TODO we need to filter to ensure we only deliver those
 // messages which are part of instance->my_deliver_memb
@@ -2207,8 +2218,15 @@ int totemsrp_mcast (
 	struct message_item message_item;
 	char *addr;
 	unsigned int addr_idx;
+	struct cs_queue *queue_use;
 
-	if (cs_queue_is_full (&instance->new_message_queue)) {
+	if (instance->waiting_trans_ack) {
+		queue_use = &instance->new_message_queue_trans;
+	} else {
+		queue_use = &instance->new_message_queue;
+	}
+
+	if (cs_queue_is_full (queue_use)) {
 		log_printf (instance->totemsrp_log_level_debug, "queue full\n");
 		return (-1);
 	}
@@ -2246,7 +2264,7 @@ int totemsrp_mcast (
 
 	TRACE1 ("mcasted message added to pending queue\n");
 	instance->stats.mcast_tx++;
-	cs_queue_item_add (&instance->new_message_queue, &message_item);
+	cs_queue_item_add (queue_use, &message_item);
 
 	return (0);
 
@@ -2261,8 +2279,14 @@ int totemsrp_avail (void *srp_context)
 {
 	struct totemsrp_instance *instance = (struct totemsrp_instance *)srp_context;
 	int avail;
+	struct cs_queue *queue_use;
 
-	cs_queue_avail (&instance->new_message_queue, &avail);
+	if (instance->waiting_trans_ack) {
+		queue_use = &instance->new_message_queue_trans;
+	} else {
+		queue_use = &instance->new_message_queue;
+	}
+	cs_queue_avail (queue_use, &avail);
 
 	return (avail);
 }
@@ -2423,7 +2447,12 @@ static int orf_token_mcast (
 		sort_queue = &instance->recovery_sort_queue;
 		reset_token_retransmit_timeout (instance); // REVIEWED
 	} else {
-		mcast_queue = &instance->new_message_queue;
+		if (instance->waiting_trans_ack) {
+			mcast_queue = &instance->new_message_queue_trans;
+		} else {
+			mcast_queue = &instance->new_message_queue;
+		}
+
 		sort_queue = &instance->regular_sort_queue;
 	}
 
@@ -3325,13 +3354,22 @@ static void token_callbacks_execute (
 static unsigned int backlog_get (struct totemsrp_instance *instance)
 {
 	unsigned int backlog = 0;
+	struct cs_queue *queue_use = NULL;
 
 	if (instance->memb_state == MEMB_STATE_OPERATIONAL) {
 		backlog = cs_queue_used (&instance->new_message_queue);
+		if (instance->waiting_trans_ack) {
+			queue_use = &instance->new_message_queue_trans;
+		} else {
+			queue_use = &instance->new_message_queue;
+		}
 	} else
 	if (instance->memb_state == MEMB_STATE_RECOVERY) {
 		backlog = cs_queue_used (&instance->retrans_message_queue);
+		queue_use = &instance->retrans_message_queue;
 	}
+	backlog = cs_queue_used (queue_use);
+	
 	instance->stats.token[instance->stats.latest_token].backlog_calc = backlog;
 	return (backlog);
 }
@@ -4517,3 +4555,10 @@ int totemsrp_member_remove (
 
 	return (res);
 }
+
+void totemsrp_trans_ack (void *context)
+{
+	struct totemsrp_instance *instance = (struct totemsrp_instance *)context;
+
+	instance->waiting_trans_ack = 0;
+}
diff --git a/exec/totemsrp.h b/exec/totemsrp.h
index 55f7ce2..f6e172f 100644
--- a/exec/totemsrp.h
+++ b/exec/totemsrp.h
@@ -130,4 +130,7 @@ extern int totemsrp_member_remove (
 	const struct totem_ip_address *member,
 	int ring_no);
 	
+void totemsrp_trans_ack (
+	void *srp_context);
+
 #endif /* TOTEMSRP_H_DEFINED */
diff --git a/include/corosync/totem/totempg.h b/include/corosync/totem/totempg.h
index 26447aa..8781561 100644
--- a/include/corosync/totem/totempg.h
+++ b/include/corosync/totem/totempg.h
@@ -168,6 +168,8 @@ extern int totempg_member_remove (
 	const struct totem_ip_address *member,
 	int ring_no);
 
+extern void totempg_trans_ack (void);
+
 #ifdef __cplusplus
 }
 #endif
-- 
1.7.1

