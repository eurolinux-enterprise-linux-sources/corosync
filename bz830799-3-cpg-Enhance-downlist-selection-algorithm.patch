From 64d0e5ace025cc929e42896c5d6beb3ef75b8244 Mon Sep 17 00:00:00 2001
From: Jan Friesse <jfriesse@redhat.com>
Date: Thu, 14 Jun 2012 09:13:47 +0200
Subject: [PATCH] cpg: Enhance downlist selection algorithm

Let's say we have 2 nodes:
- node 2 is paused
- node 1 create membership (one node)
- node 2 is unpaused

Result is that node 1 downlist is selected, so it means that
from node 2 point of view, node 1 was never down.

Patch solves situation by adding additional check for largest
previous membership.

So current tests are:
1) largest (previous #nodes - #nodes know to have left)
2) (then) largest previous membership
3) (and last as a tie-breaker) node with smallest nodeid

Signed-off-by: Jan Friesse <jfriesse@redhat.com>
Reviewed-by: Steven Dake <sdake@redhat.com>
---
 services/cpg.c |   17 +++++++++--------
 1 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/services/cpg.c b/services/cpg.c
index 37ae6b7..2bc85bf 100644
--- a/services/cpg.c
+++ b/services/cpg.c
@@ -816,16 +816,17 @@ static struct downlist_msg* downlist_master_choose (void)
 		best_members = best->old_members - best->left_nodes;
 		cmp_members = cmp->old_members - cmp->left_nodes;
 
-		if (cmp_members < best_members) {
-			continue;
-		}
-		else if (cmp_members > best_members) {
-			best = cmp;
-		}
-		else if (cmp->sender_nodeid < best->sender_nodeid) {
+		if (cmp_members > best_members) {
 			best = cmp;
+		} else if (cmp_members == best_members) {
+			if (cmp->old_members > best->old_members) {
+				best = cmp;
+			} else if (cmp->old_members == best->old_members) {
+				if (cmp->sender_nodeid < best->sender_nodeid) {
+					best = cmp;
+				}
+			}
 		}
-
 	}
 
 	assert (best != NULL);
-- 
1.7.1

