From 013b4ba8ebdc089da76313d43b1454fe324d597b Mon Sep 17 00:00:00 2001
From: Jan Friesse <jfriesse@redhat.com>
Date: Thu, 25 Apr 2013 16:20:24 +0200
Subject: [PATCH] Free confdb message holder list on confdb exit

This operation will not only properly free memory, but also decreases
connection reference(s). This should solve deadloop in
coroipcs_ipc_service_exit, because confdb_exit_fn removes not only
notify_pipe but also deletes poll_dispatch, so nobody is left to
unreference connections.

Signed-off-by: Jan Friesse <jfriesse@redhat.com>
Reviewed-by: Fabio M. Di Nitto <fdinitto@redhat.com>
---
 services/confdb.c |   20 ++++++++++++++++++++
 1 files changed, 20 insertions(+), 0 deletions(-)

diff --git a/services/confdb.c b/services/confdb.c
index 1559604..acedb96 100644
--- a/services/confdb.c
+++ b/services/confdb.c
@@ -348,11 +348,31 @@ __attribute__ ((constructor)) static void corosync_lcr_component_register (void)
 	lcr_component_register (&confdb_comp_ver0);
 }
 
+static void free_confdb_ipc_message_holder_list(void)
+{
+	struct confdb_ipc_message_holder *holder;
+
+	pthread_mutex_lock (&confdb_ipc_message_holder_list_mutex);
+
+	while (!list_empty (&confdb_ipc_message_holder_list_head)) {
+		holder = list_entry (confdb_ipc_message_holder_list_head.next,
+			    struct confdb_ipc_message_holder, list);
+		list_del (&holder->list);
+		api->ipc_refcnt_dec(holder->conn);
+		free(holder);
+	}
+
+	pthread_mutex_unlock (&confdb_ipc_message_holder_list_mutex);
+}
+
 static int confdb_exec_exit_fn(void)
 {
 	api->poll_dispatch_delete(api->poll_handle_get(), notify_pipe[0]);
 	close(notify_pipe[0]);
 	close(notify_pipe[1]);
+
+	free_confdb_ipc_message_holder_list();
+
 	return 0;
 }
 
-- 
1.7.1

