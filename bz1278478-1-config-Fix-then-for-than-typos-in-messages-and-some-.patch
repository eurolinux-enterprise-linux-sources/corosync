From 1be4f7b899f91a8dc23ade10c539177f2b39d88e Mon Sep 17 00:00:00 2001
From: Christine Caulfield <ccaulfie@redhat.com>
Date: Fri, 25 Jul 2014 08:11:00 +0100
Subject: [PATCH] config: Fix 'then' for 'than' typos in messages and some comments.

Also fix a 'delier' for 'deliver', which I only spotted because the line
had a (correct) 'then' on it!

Signed-Off-By: Christine Caulfield <ccaulfie@redhat.com>
Reviewed-by:  Jan Friesse <jfriesse@redhat.com>
---
 exec/coroipcs.c    |    2 +-
 exec/coroparse.c   |    2 +-
 exec/totemconfig.c |   30 +++++++++++++++---------------
 exec/totempg.c     |    2 +-
 exec/totemrrp.c    |    4 ++--
 exec/totemsrp.c    |    6 +++---
 6 files changed, 23 insertions(+), 23 deletions(-)

diff --git a/exec/coroipcs.c b/exec/coroipcs.c
index e16b473..77f5d8d 100644
--- a/exec/coroipcs.c
+++ b/exec/coroipcs.c
@@ -1774,7 +1774,7 @@ int coroipcs_handler_dispatch (
 
 		pthread_attr_init (&conn_info->thread_attr);
 		/*
-		* IA64 needs more stack space then other arches
+		* IA64 needs more stack space than other arches
 		*/
 		#if defined(__ia64__)
 		pthread_attr_setstacksize (&conn_info->thread_attr, 400000);
diff --git a/exec/coroparse.c b/exec/coroparse.c
index d1c7803..987b112 100644
--- a/exec/coroparse.c
+++ b/exec/coroparse.c
@@ -227,7 +227,7 @@ static int parser_check_item_uidgid(struct objdb_iface_ver0 *objdb,
 		}
 
 		if (strcmp (name, "uidgid") != 0) {
-			*error_string = "uidgid: Can't add subsection different then uidgid";
+			*error_string = "uidgid: Can't add subsection different than uidgid";
 			return 0;
 		}
 	}
diff --git a/exec/totemconfig.c b/exec/totemconfig.c
index 99dd815..1e05c5b 100644
--- a/exec/totemconfig.c
+++ b/exec/totemconfig.c
@@ -367,7 +367,7 @@ printf ("couldn't find totem handle\n");
 
 		if (ringnumber >= INTERFACE_MAX) {
 			snprintf (error_string_response, sizeof(error_string_response),
-			    "parse error in config: interface ring number %u is bigger then allowed maximum %u\n",
+			    "parse error in config: interface ring number %u is bigger than allowed maximum %u\n",
 			    ringnumber, INTERFACE_MAX - 1);
 
 			*error_string = error_string_response;
@@ -562,7 +562,7 @@ int totem_config_validate (
 
 	if (totem_config->max_network_delay < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The max_network_delay parameter (%d ms) may not be less then (%d ms).",
+			"The max_network_delay parameter (%d ms) may not be less than (%d ms).",
 			totem_config->max_network_delay, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -581,7 +581,7 @@ int totem_config_validate (
 
 	if (totem_config->token_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The token timeout parameter (%d ms) may not be less then (%d ms).",
+			"The token timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->token_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -598,7 +598,7 @@ int totem_config_validate (
 	}
 	if (totem_config->token_retransmit_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The token retransmit timeout parameter (%d ms) may not be less then (%d ms).",
+			"The token retransmit timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->token_retransmit_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -609,7 +609,7 @@ int totem_config_validate (
 
 	if (totem_config->token_hold_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The token hold timeout parameter (%d ms) may not be less then (%d ms).",
+			"The token hold timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->token_hold_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -620,7 +620,7 @@ int totem_config_validate (
 
 	if (totem_config->join_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The join timeout parameter (%d ms) may not be less then (%d ms).",
+			"The join timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->join_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -631,7 +631,7 @@ int totem_config_validate (
 
 	if (totem_config->consensus_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The consensus timeout parameter (%d ms) may not be less then (%d ms).",
+			"The consensus timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->consensus_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -642,7 +642,7 @@ int totem_config_validate (
 
 	if (totem_config->merge_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The merge timeout parameter (%d ms) may not be less then (%d ms).",
+			"The merge timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->merge_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -653,7 +653,7 @@ int totem_config_validate (
 
 	if (totem_config->downcheck_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The downcheck timeout parameter (%d ms) may not be less then (%d ms).",
+			"The downcheck timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->downcheck_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -673,7 +673,7 @@ int totem_config_validate (
 	}
 	if (totem_config->rrp_problem_count_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The RRP problem count timeout parameter (%d ms) may not be less then (%d ms).",
+			"The RRP problem count timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->rrp_problem_count_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -685,13 +685,13 @@ int totem_config_validate (
 	}
 	if (totem_config->rrp_problem_count_threshold < RRP_PROBLEM_COUNT_THRESHOLD_MIN) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The RRP problem count threshold (%d problem count) may not be less then (%d problem count).",
+			"The RRP problem count threshold (%d problem count) may not be less than (%d problem count).",
 			totem_config->rrp_problem_count_threshold, RRP_PROBLEM_COUNT_THRESHOLD_MIN);
 		goto parse_error;
 	}
 	if (totem_config->rrp_problem_count_mcast_threshold < RRP_PROBLEM_COUNT_THRESHOLD_MIN) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The RRP multicast problem count threshold (%d problem count) may not be less then (%d problem count).",
+			"The RRP multicast problem count threshold (%d problem count) may not be less than (%d problem count).",
 			totem_config->rrp_problem_count_mcast_threshold, RRP_PROBLEM_COUNT_THRESHOLD_MIN);
 		goto parse_error;
 	}
@@ -702,7 +702,7 @@ int totem_config_validate (
 
 	if (totem_config->rrp_token_expired_timeout < MINIMUM_TIMEOUT) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The RRP token expired timeout parameter (%d ms) may not be less then (%d ms).",
+			"The RRP token expired timeout parameter (%d ms) may not be less than (%d ms).",
 			totem_config->rrp_token_expired_timeout, MINIMUM_TIMEOUT);
 		goto parse_error;
 	}
@@ -736,7 +736,7 @@ int totem_config_validate (
 
 	if ((MESSAGE_QUEUE_MAX) < totem_config->max_messages) {
 		snprintf (local_error_reason, sizeof(local_error_reason),
-			"The max_messages parameter (%d messages) may not be greater then (%d messages).",
+			"The max_messages parameter (%d messages) may not be greater than (%d messages).",
 			totem_config->max_messages, MESSAGE_QUEUE_MAX);
 		goto parse_error;
 	}
@@ -748,7 +748,7 @@ int totem_config_validate (
 		totem_config->threads = 0;
 	}
 	if (totem_config->net_mtu > FRAME_SIZE_MAX) {
-		error_reason = "This net_mtu parameter is greater then the maximum frame size";
+		error_reason = "This net_mtu parameter is greater than the maximum frame size";
 		goto parse_error;
 	}
 	if (totem_config->vsf_type == NULL) {
diff --git a/exec/totempg.c b/exec/totempg.c
index a6319ca..ee532ab 100644
--- a/exec/totempg.c
+++ b/exec/totempg.c
@@ -117,7 +117,7 @@ struct totempg_mcast_header {
 
 #if !(defined(__i386__) || defined(__x86_64__))
 /*
- * Need align on architectures different then i386 or x86_64
+ * Need align on architectures different than i386 or x86_64
  */
 #define TOTEMPG_NEED_ALIGN 1
 #endif
diff --git a/exec/totemrrp.c b/exec/totemrrp.c
index e76d346..bbc70c3 100644
--- a/exec/totemrrp.c
+++ b/exec/totemrrp.c
@@ -505,7 +505,7 @@ static void active_timer_problem_decrementer_cancel (
  * Threshold value when recv_count for passive rrp should be adjusted.
  * Set this value to some smaller for testing of adjusting proper
  * functionality. Also keep in mind that this value must be smaller
- * then rrp_problem_count_threshold
+ * than rrp_problem_count_threshold
  */
 #define PASSIVE_RECV_COUNT_THRESHOLD		(INT_MAX / 2)
 
@@ -913,7 +913,7 @@ static void passive_monitor (
 	}
 
 	/*
-	 * Max is larger then threshold -> start adjusting process
+	 * Max is larger than threshold -> start adjusting process
 	 */
 	if (max > PASSIVE_RECV_COUNT_THRESHOLD) {
 		min_all = min_active = recv_count[iface_no];
diff --git a/exec/totemsrp.c b/exec/totemsrp.c
index 9aa94d9..f01b57a 100644
--- a/exec/totemsrp.c
+++ b/exec/totemsrp.c
@@ -44,7 +44,7 @@
  * - encryption of message contents with SOBER128
  * - authentication of meessage contents with SHA1/HMAC
  * - token hold mode where token doesn't rotate on unused ring - reduces cpu
- *   usage on 1.6ghz xeon from 35% to less then .1 % as measured by top
+ *   usage on 1.6ghz xeon from 35% to less than .1 % as measured by top
  */
 
 #include <config.h>
@@ -1833,7 +1833,7 @@ static void memb_state_operational_enter (struct totemsrp_instance *instance)
 	 * to my_high_seq_received
 	 *
 	 * What should really happen is we should deliver all messages up to
-	 * a gap, then delier the transitional configuration, then deliver
+	 * a gap, then deliver the transitional configuration, then deliver
 	 * the messages between the first gap and my_high_seq_received, then
 	 * deliver a regular configuration, then deliver the regular
 	 * configuration
@@ -2839,7 +2839,7 @@ static void memb_state_commit_token_update (
 	memb_list[instance->commit_token->memb_index].high_delivered = instance->my_high_delivered;
 	/*
 	 * find high aru up to current memb_index for all matching ring ids
-	 * if any ring id matching memb_index has aru less then high aru set
+	 * if any ring id matching memb_index has aru less than high aru set
 	 * received flag for that entry to false
 	 */
 	high_aru = memb_list[instance->commit_token->memb_index].aru;
-- 
1.7.1

